/*
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/mcp-perplexity/src/server/PerplexityService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for interacting with the Perplexity API
 * Making API calls so you don't have to! ðŸš€
 */

import axios, { AxiosInstance, AxiosError } from "axios";
import { API_CONSTANTS } from "../types/Constants.js";
import { PerplexityConfig } from "../types/PerplexityConfig.js";
import { ChatCompletionResponse } from "../types/PerplexityTypes.js";
import { PerplexityValidator } from "./PerplexityValidator.js";
import { Logger, LogMessages } from "./Logger.js";

/**
 * Custom error class for Perplexity API errors
 */
class PerplexityApiError extends Error {
  constructor(error: AxiosError) {
    super(`Perplexity API Error: ${error.message}`);
    this.name = "PerplexityApiError";
    this.cause = error;
  }
}

/**
 * Singleton service that handles all direct communication with the Perplexity API
 */
export class PerplexityService {
  private static instance: PerplexityService;
  private readonly client: AxiosInstance;
  private readonly apiKey: string;

  /**
   * Private constructor for singleton pattern
   * @param apiKey - Perplexity API key
   */
  private constructor(apiKey: string) {
    this.apiKey = apiKey;
    this.client = axios.create({
      baseURL: API_CONSTANTS.BASE_URL,
      timeout: API_CONSTANTS.TIMEOUT_MS,
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
    });
  }

  /**
   * Gets the singleton instance of the service
   * @param apiKey - Perplexity API key
   * @returns The singleton instance
   */
  public static getInstance(apiKey: string): PerplexityService {
    if (!PerplexityService.instance) {
      PerplexityService.instance = new PerplexityService(apiKey);
    }
    return PerplexityService.instance;
  }

  /**
   * Makes a chat completion request to the Perplexity API
   * @param config - Configuration for the chat completion
   * @returns The API response
   * @throws {PerplexityApiError} If the API request fails
   */
  public async createChatCompletion(
    config: PerplexityConfig
  ): Promise<ChatCompletionResponse> {
    // Validate the config
    const validatedConfig = PerplexityValidator.validateConfig(config);

    await Logger.trace(LogMessages.API_REQUEST_START);

    try {
      const response = await this.makeRequest(
        "/chat/completions",
        validatedConfig
      );
      const validatedResponse = PerplexityValidator.validateResponse(response);

      await Logger.trace(LogMessages.API_RESPONSE_RECEIVED);
      return validatedResponse;
    } catch (error) {
      await Logger.trace(
        `${LogMessages.API_ERROR}: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
      throw error;
    }
  }

  /**
   * Makes an HTTP request with retry logic
   * @param endpoint - API endpoint
   * @param data - Request data
   * @returns The API response
   * @throws {PerplexityApiError} If all retry attempts fail
   */
  private async makeRequest(endpoint: string, data: unknown): Promise<unknown> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= API_CONSTANTS.MAX_RETRIES; attempt++) {
      try {
        const response = await this.client.post(endpoint, data);
        return response.data;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error("Unknown error");

        if (!this.shouldRetry(error) || attempt === API_CONSTANTS.MAX_RETRIES) {
          if (axios.isAxiosError(error)) {
            throw new PerplexityApiError(error);
          }
          throw error;
        }

        await this.delay(attempt);
      }
    }

    throw lastError;
  }

  /**
   * Determines if a request should be retried based on the error
   * @param error - The error to check
   * @returns True if the request should be retried
   */
  private shouldRetry(error: unknown): boolean {
    if (!axios.isAxiosError(error)) return false;

    // Retry on network errors
    if (!error.response) return true;

    const status = error.response.status;

    // Retry on rate limits (429) and server errors (500-599)
    return status === 429 || (status >= 500 && status <= 599);
  }

  /**
   * Implements exponential backoff delay
   * @param attempt - The current retry attempt number
   */
  private async delay(attempt: number): Promise<void> {
    const delayMs = API_CONSTANTS.RETRY_DELAY_MS * Math.pow(2, attempt - 1);
    await new Promise((resolve) => setTimeout(resolve, delayMs));
  }
}
