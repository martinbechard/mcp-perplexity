/*
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/mcp-perplexity/src/server/PerplexityServer.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * MCP Server implementation for the Perplexity API
 * Where MCP meets API - the grand unification! ü§ù
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  TextContent,
} from "@modelcontextprotocol/sdk/types.js";
import { PerplexityService } from "./PerplexityService.js";
import { PerplexityConfig } from "../types/PerplexityConfig.js";
import { API_CONSTANTS } from "../types/Constants.js";
import { Logger, LogMessages } from "./Logger.js";
import { Message } from "../types/PerplexityTypes.js";
import { PerplexityValidator } from "./PerplexityValidator.js";

interface PerplexitySearchArgs {
  messages: Message[];
  searchDomainFilter?: string[];
}

/**
 * Main server class implementing the Model Context Protocol for Perplexity API integration
 */
export class PerplexityServer {
  private server: Server;
  private perplexityService: PerplexityService;

  /**
   * Initializes the Perplexity MCP server
   * @param apiKey - Perplexity API key
   * @param debug - Whether debug mode is enabled
   */
  constructor(apiKey: string, debug: boolean = false) {
    this.server = new Server(
      {
        name: "perplexity-mcp-server",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
          prompts: {},
          sampling: {},
          resources: {},
        },
      }
    );

    this.perplexityService = PerplexityService.getInstance(apiKey);
    this.setupHandlers();
  }

  /**
   * Performs any necessary initialization
   */
  async initialize(): Promise<void> {
    if (Logger.isDebugEnabled()) {
      await Logger.trace("Debug mode enabled");
      await Logger.trace("Server initializing");
    }
    await Logger.trace(LogMessages.SERVER_START);
  }

  /**
   * Returns the underlying MCP server instance
   */
  getServer(): Server {
    return this.server;
  }

  /**
   * Sets up all MCP protocol handlers
   */
  private setupHandlers(): void {
    // Tool handlers
    this.server.setRequestHandler(ListToolsRequestSchema, async (request) => {
      if (Logger.isDebugEnabled()) {
        await Logger.trace("Protocol: ListTools request received");
      }

      const response = {
        tools: [
          {
            name: "perplexity_search",
            description:
              "Search the internet and get AI-powered answers using Perplexity API",
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                },
                searchDomainFilter: {
                  type: "array",
                  items: {
                    type: "string",
                  },
                  description:
                    "Optional list of domains to restrict search results",
                },
              },
              required: ["messages"],
            },
          },
        ],
      };

      if (Logger.isDebugEnabled()) {
        await Logger.trace("Protocol: ListTools response ready");
      }

      return response;
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      if (Logger.isDebugEnabled()) {
        await Logger.trace(
          `Protocol: CallTool request for ${request.params.name}`
        );
        await Logger.trace("Request params:", request.params);
      }

      try {
        const { name, arguments: args } = request.params;

        switch (name) {
          case "perplexity_search": {
            if (!args || typeof args !== "object") {
              throw new Error("Invalid arguments: expected object");
            }

            await Logger.trace(LogMessages.TOOL_CALL_RECEIVED, {
              tool: "perplexity_search",
              query: args.query,
              domainFilters: args.searchDomainFilter,
            });

            // Validate messages
            if (Logger.isDebugEnabled()) {
              await Logger.trace("Validating messages:", args.messages);
            }

            const query = args.query as string;

            if (!query) {
              throw new Error("Query must not be empty");
            }

            await Logger.trace(LogMessages.VALIDATION_COMPLETE, {
              type: "query",
            });

            const config: PerplexityConfig = {
              model: API_CONSTANTS.DEFAULT_MODEL,
              messages: [{ role: "user", content: query }],
              searchDomainFilter: Array.isArray(args.searchDomainFilter)
                ? args.searchDomainFilter
                : undefined,
              temperature: API_CONSTANTS.DEFAULT_TEMPERATURE,
              topP: API_CONSTANTS.DEFAULT_TOP_P,
              returnRelatedQuestions: true,
            };

            // Validate entire config
            if (Logger.isDebugEnabled()) {
              await Logger.trace("Validating config:", config);
            }

            const validatedConfig = PerplexityValidator.validateConfig(config);

            await Logger.trace(LogMessages.VALIDATION_COMPLETE, {
              type: "config",
              config: validatedConfig,
            });

            await Logger.trace(LogMessages.API_REQUEST_START, {
              config: validatedConfig,
            });

            if (Logger.isDebugEnabled()) {
              await Logger.trace(
                "Making API request with config:",
                validatedConfig
              );
            }

            const apiResponse =
              await this.perplexityService.createChatCompletion(
                validatedConfig
              );

            if (Logger.isDebugEnabled()) {
              await Logger.trace("Raw API response:", apiResponse);
            }

            await Logger.trace(LogMessages.API_RESPONSE_RECEIVED, {
              response: apiResponse,
            });

            const response = {
              content: [
                {
                  type: "text",
                  text: apiResponse.choices[0].message.content,
                } as TextContent,
                {
                  type: "text",
                  text: "\n\nSources:\n" + apiResponse.citations.join("\n"),
                } as TextContent,
              ],
            };

            await Logger.trace(LogMessages.RESPONSE_FORMATTED, {
              response: response,
            });

            return response;
          }

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        // Always log errors regardless of debug mode
        const errorMsg =
          error instanceof Error ? error.stack || error.message : String(error);
        await Logger.error(`Error in tool call: ${errorMsg}`, error);

        if (Logger.isDebugEnabled() && error instanceof Error) {
          await Logger.trace("Error details:", {
            name: error.name,
            message: error.message,
            stack: error.stack,
          });
        }

        console.error("Tool call error:", error);

        const errorResponse = {
          content: [
            {
              type: "text",
              text: `Error: ${
                error instanceof Error ? error.message : String(error)
              }`,
            },
          ],
          isError: true,
        };

        if (Logger.isDebugEnabled()) {
          await Logger.trace(
            "Protocol: CallTool error response ready",
            errorResponse
          );
        }

        return errorResponse;
      }
    });

    // Resource handlers for logs
    this.server.setRequestHandler(
      ListResourcesRequestSchema,
      async (request) => {
        if (Logger.isDebugEnabled()) {
          await Logger.trace("Protocol: ListResources request received");
        }

        const response = {
          resources: [
            {
              uri: "logs://current",
              name: "Current Server Logs",
              description: "View the current server logs without clearing them",
              mimeType: "text/plain",
            },
          ],
        };

        if (Logger.isDebugEnabled()) {
          await Logger.trace("Protocol: ListResources response ready");
        }

        return response;
      }
    );

    // Resource template handler for log tail
    this.server.setRequestHandler(
      ListResourceTemplatesRequestSchema,
      async () => {
        if (Logger.isDebugEnabled()) {
          await Logger.trace(
            "Protocol: ListResourceTemplates request received"
          );
        }

        const response = {
          resourceTemplates: [
            {
              uriTemplate: "logs://tail/{length}",
              name: "Last N Server Logs",
              description: "View the last N server log entries (default: 10)",
              mimeType: "text/plain",
              parameters: {
                length: {
                  type: "integer",
                  description: "Number of log entries to return",
                  default: 10,
                  minimum: 1,
                  required: false,
                },
              },
            },
          ],
        };

        if (Logger.isDebugEnabled()) {
          await Logger.trace("Protocol: ListResourceTemplates response ready");
        }

        return response;
      }
    );

    this.server.setRequestHandler(
      ReadResourceRequestSchema,
      async (request) => {
        if (Logger.isDebugEnabled()) {
          await Logger.trace(
            `Protocol: ReadResource request for ${request.params.uri}`
          );
        }

        try {
          if (request.params.uri === "logs://current") {
            const response = {
              contents: [
                {
                  uri: request.params.uri,
                  mimeType: "text/markdown",
                  text:
                    Logger.getLogContent().join("<BR>\n") ||
                    "No logs available",
                },
              ],
            };

            if (Logger.isDebugEnabled()) {
              await Logger.trace(
                "Protocol: ReadResource response ready",
                response
              );
            }

            return response;
          }

          // Handle both forms: logs://tail and logs://tail/{length}
          const tailMatch = request.params.uri.match(
            /^logs:\/\/tail(?:\/(\d*))?$/
          );
          if (tailMatch) {
            const length = tailMatch[1] ? parseInt(tailMatch[1], 10) : 10;

            if (length < 1) {
              throw new Error("Length parameter must be a positive integer");
            }

            const logs = Logger.getLogContent();
            const tailLogs = logs.slice(-length);

            const response = {
              contents: [
                {
                  uri: request.params.uri,
                  mimeType: "text/markdown",
                  text: tailLogs.join("<BR>\n") || "No logs available",
                },
              ],
            };

            if (Logger.isDebugEnabled()) {
              await Logger.trace(
                "Protocol: ReadResource response ready",
                response
              );
            }

            return response;
          }

          throw new Error(`Resource not found: ${request.params.uri}`);
        } catch (error) {
          // Always log errors regardless of debug mode
          const errorMsg =
            error instanceof Error
              ? error.stack || error.message
              : String(error);
          await Logger.error(`Error reading resource: ${errorMsg}`, error);
          console.error("Resource error:", error);
          throw error; // Re-throw to let MCP SDK handle error response
        }
      }
    );

    Logger.trace(LogMessages.HANDLER_SETUP).catch(console.error);
  }
}
