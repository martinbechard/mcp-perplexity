<!--
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: /Users/martinbechard/dev/mcp-perplexity/design/PerplexityServer.md
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

Design document for the Perplexity MCP Server implementation
Where MCP meets API - the grand unification!
-->

# Design Context and Background

## Purpose

This server provides integration between the Model Context Protocol (MCP) and Perplexity's AI-powered internet search API. Unlike a simple chat completion service, this implementation focuses specifically on enabling internet search capabilities with AI-enhanced responses.

## Key Design Decisions

1. Internet Search Focus

   - The server exposes a single tool named 'perplexity_search'
   - Each query is processed as an internet search request
   - Responses include both AI-generated answers and source citations

2. Logging Architecture

   - Logger class handles actual logging implementation
   - PerplexityServer exposes logs through MCP resource handlers
   - Uses JavaScript template literals for log messages instead of message templates
   - Follows the example filesystem server's logging pattern
   - Supports retrieving the last N log entries through logs://tail/{length}

3. MCP Integration Points
   - Tool Registration: Exposes search functionality
   - Resource Handlers: Provides access to execution logs
   - Error Handling: Maintains consistent MCP response format

## Maintenance Notes

- Tool Configuration: When updating tool parameters, ensure corresponding updates in PerplexityConfig
- Error Handling: All errors must be formatted as MCP responses
- Logging: Add logs for significant operations to help with debugging
- Citations: Always include source citations in responses for transparency

# Table of Contents

- Class: PerplexityServer

---

# Class: PerplexityServer

## Overview

Main server class that implements the Model Context Protocol and integrates with the Perplexity API for internet search capabilities

## Design Requirements

1. MUST implement MCP protocol using SDK
   Source: High-level design document
2. MUST use PerplexityService for API calls
   Source: High-level design document
3. MUST handle tool registration and execution
   Source: High-level design document
4. MUST follow example filesystem server pattern
   Source: Project knowledge base
5. MUST expose server logs through MCP resources
   Source: Example filesystem server implementation
6. MUST support retrieving last N log entries
   Source: Requirements update

## Design Considerations

1. Tool Registration Strategy

   - WHY: Provide clear interface for MCP tools
   - HOW: Register tools with detailed schemas and handlers
   - EXAMPLE:
     ```typescript
     this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
       tools: [
         {
           name: "perplexity_search",
           description:
             "Search the internet and get AI-powered answers using Perplexity API",
           inputSchema: {
             type: "object",
             properties: {
               messages: {
                 type: "array",
                 items: messageSchema,
               },
               searchDomainFilter: {
                 type: "array",
                 items: { type: "string" },
                 description:
                   "Optional list of domains to restrict search results",
               },
             },
           },
         },
       ],
     }));
     ```

2. Resource Handlers

   - WHY: Expose server logs through MCP protocol
   - HOW: Implement ListResourcesRequestSchema and ReadResourceRequestSchema handlers
   - EXAMPLE:

     ```typescript
     this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
       resources: [
         {
           uri: "logs://current",
           name: "Current Server Logs",
           description: "View the current server logs without clearing them",
           mimeType: "text/plain",
         },
         {
           uri: "logs://tail/{length}",
           name: "Last N Server Logs",
           description: "View the last N server log entries (default: 10)",
           mimeType: "text/plain",
         },
       ],
     }));

     this.server.setRequestHandler(
       ReadResourceRequestSchema,
       async (request) => {
         if (request.params.uri === "logs://current") {
           return {
             contents: [
               {
                 uri: request.params.uri,
                 mimeType: "text/markdown",
                 text:
                   Logger.getLogContent().join("<BR>\n") || "No logs available",
               },
             ],
           };
         }

         const tailMatch = request.params.uri.match(/^logs:\/\/tail\/(\d*)$/);
         if (tailMatch) {
           const length = tailMatch[1] ? parseInt(tailMatch[1], 10) : 10;
           if (length < 1) {
             throw new Error("Length parameter must be a positive integer");
           }
           const logs = Logger.getLogContent();
           const tailLogs = logs.slice(-length);
           return {
             contents: [
               {
                 uri: request.params.uri,
                 mimeType: "text/markdown",
                 text: tailLogs.join("<BR>\n") || "No logs available",
               },
             ],
           };
         }

         throw new Error(`Resource not found: ${request.params.uri}`);
       }
     );
     ```

3. Error Response Formatting

   - WHY: Provide consistent error responses
   - HOW: Map API errors to MCP response format
   - EXAMPLE:
     ```typescript
     return {
       content: [
         {
           type: "text",
           text: `Error: ${error.message}`,
         },
       ],
       isError: true,
     };
     ```

4. Tool Request Handling

   - WHY: Process tool calls to perplexity_search
   - HOW: Implement CallToolRequestSchema handler
   - EXAMPLE:

     ```typescript
     this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
       const { name, arguments: args } = request.params;

       switch (name) {
         case "perplexity_search": {
           await Logger.trace(`Tool call received: ${name}`);

           try {
             const config: PerplexityConfig = {
               model: API_CONSTANTS.DEFAULT_MODEL,
               messages: args.messages,
               searchDomainFilter: args.searchDomainFilter,
               temperature: API_CONSTANTS.DEFAULT_TEMPERATURE,
               topP: API_CONSTANTS.DEFAULT_TOP_P,
               returnRelatedQuestions: true,
             };

             const response = await this.perplexityService.createChatCompletion(
               config
             );
             await Logger.trace("API response received");

             return {
               content: [
                 {
                   type: "text",
                   text: response.choices[0].message.content,
                 },
                 {
                   type: "text",
                   text: "\n\nSources:\n" + response.citations.join("\n"),
                 },
               ],
             };
           } catch (error) {
             await Logger.trace(`Error in tool call: ${error}`);
             return {
               content: [
                 {
                   type: "text",
                   text: `Error: ${
                     error instanceof Error ? error.message : String(error)
                   }`,
                 },
               ],
               isError: true,
             };
           }
         }

         default: {
           throw new Error(`Unknown tool: ${name}`);
         }
       }
     });
     ```

## Main Functions

1. constructor(apiKey: string)

   - Initializes the server and services
   - Pseudocode:
     ```typescript
     - Create MCP Server instance
     - Initialize PerplexityService
     - Setup handlers
     - Set server capabilities
     ```

2. private setupHandlers()

   - Sets up all MCP protocol handlers
   - Pseudocode:
     ```typescript
     - Register resource handlers (logs://current, logs://tail/{length})
     - Register tool handlers (perplexity_search)
     - Register prompt handlers
     - Setup error handlers
     ```

3. private async handlePerplexitySearch(request: CallToolRequest): Promise<ToolCallResponse>

   - Handles internet search and answer generation
   - Pseudocode:
     ```typescript
     - Extract messages and searchDomainFilter from request
     - Validate inputs using PerplexityValidator
     - Create config with default values
     - Set search-specific options (returnRelatedQuestions=true)
     - Call PerplexityService.createChatCompletion
     - Format response as text content
     - Add citations as separate text content
     - Return combined MCP response
     - Handle errors with appropriate MCP error response
     ```

4. async initialize(): Promise<void>

   - Performs any necessary initialization
   - No complex pseudocode needed

5. getServer(): Server
   - Returns the MCP server instance
   - No complex pseudocode needed

## Attributes

The Perplexity API requires a conversation, however, for now we will just accept a single query and create a user message with it.

```typescript
class PerplexityServer {
    private server: Server;
    private perplexityService: PerplexityService;

    constructor(apiKey: string) {
        this.server = new Server({
            name: 'perplexity-mcp-server',
            version: '1.0.0'
        }, {
            capabilities: {
                tools: {
                    perplexity_search: {
                        description: 'Search the internet and get AI-powered answers using Perplexity API',
                        inputSchema: {
                            type: 'object',
                            properties: {
                                query: {
                                  type: 'string'
                                }
                                searchDomainFilter: {
                                    type: 'array',
                                    items: { type: 'string' },
                                    description: 'Optional list of domains to restrict search results'
                                }
                            },
                            required: ['messages']
                        }
                    }
                },
                prompts: {},
                sampling: {},
                resources: {}
            }
        });

        this.perplexityService = PerplexityService.getInstance(apiKey);
    }
}
```